// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for `src/komodo_defi_framework.h`.
///
/// Regenerate bindings with `dart run ffigen --config ffigen.yaml`.
///
class KomodoDefiFrameworkBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  KomodoDefiFrameworkBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  KomodoDefiFrameworkBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Starts the MM2 in a detached singleton thread.
  /// /
  /// // FFI_PLUGIN_EXPORT int8_t mm2_main(const char *conf, LogCallback log_cb);
  int mm2_main(
    ffi.Pointer<ffi.Char> conf,
    LogCallback log_cb,
  ) {
    return _mm2_main(
      conf,
      log_cb,
    );
  }

  late final _mm2_mainPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int8 Function(ffi.Pointer<ffi.Char>, LogCallback)>>('mm2_main');
  late final _mm2_main = _mm2_mainPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, LogCallback)>();

  /// Checks if the MM2 singleton thread is currently running or not.
  /// 0 .. not running.
  /// 1 .. running, but no context yet.
  /// 2 .. context, but no RPC yet.
  /// 3 .. RPC is up.
  int mm2_main_status() {
    return _mm2_main_status();
  }

  late final _mm2_main_statusPtr =
      _lookup<ffi.NativeFunction<ffi.Int8 Function()>>('mm2_main_status');
  late final _mm2_main_status =
      _mm2_main_statusPtr.asFunction<int Function()>();

  /// Run a few hand-picked tests.
  ///
  /// The tests are wrapped into a library method in order to run them in such embedded environments
  /// where running "cargo test" is not an easy option.
  ///
  /// MM2 is mostly used as a library in environments where we can't simpy run it as a separate process
  /// and we can't spawn multiple MM2 instances in the same process YET
  /// therefore our usual process-spawning tests can not be used here.
  ///
  /// Returns the `torch` (as in Olympic flame torch) if the tests have passed. Panics otherwise.
  int mm2_test(
    int torch,
    LogCallback log_cb,
  ) {
    return _mm2_test(
      torch,
      log_cb,
    );
  }

  late final _mm2_testPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32, LogCallback)>>(
          'mm2_test');
  late final _mm2_test =
      _mm2_testPtr.asFunction<int Function(int, LogCallback)>();

  /// Stop an MM2 instance or reset the static variables.
  int mm2_stop() {
    return _mm2_stop();
  }

  late final _mm2_stopPtr =
      _lookup<ffi.NativeFunction<ffi.Int8 Function()>>('mm2_stop');
  late final _mm2_stop = _mm2_stopPtr.asFunction<int Function()>();
}

/// typedef void (*LogCallback)(const char *line);
typedef LogCallback = ffi.Pointer<ffi.NativeFunction<LogCallbackFunction>>;
typedef LogCallbackFunction = ffi.Void Function(ffi.Pointer<ffi.Char> line);
typedef DartLogCallbackFunction = void Function(ffi.Pointer<ffi.Char> line);
